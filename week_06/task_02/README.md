# Week 06, Task 02: Сортировка массива с подсчетом перестановок

## Описание задания

**Задача:** Ввести массив, состоящий из 12 элементов действительного типа. Расположить элементы в порядке убывания. Определить количество происшедших при этом перестановок.

## Требования

1. **Ввод массива:** Программа должна принимать 12 вещественных чисел
2. **Сортировка:** Элементы должны быть расположены в порядке убывания
3. **Подсчет перестановок:** Необходимо подсчитать количество обменов элементов при сортировке
4. **Вывод результатов:** Показать исходный и отсортированный массивы, а также количество перестановок

## Алгоритм

Используется **алгоритм пузырьковой сортировки (Bubble Sort)** с модификацией для сортировки по убыванию:

1. Сравниваем соседние элементы массива
2. Если левый элемент меньше правого, меняем их местами
3. Подсчитываем каждую перестановку
4. Повторяем процесс до полной сортировки

### Временная сложность
- **Лучший случай:** O(n) - когда массив уже отсортирован
- **Средний случай:** O(n²)
- **Худший случай:** O(n²)

### Пространственная сложность
- O(1) - сортировка на месте

## Структура программы

```
main.go
├── inputArray()           - ввод массива с клавиатуры
├── generateRandomArray()  - генерация случайного массива
├── bubbleSortDescending() - сортировка по убыванию с подсчетом перестановок
├── printArray()          - вывод массива на экран
├── chooseInputMode()     - выбор режима ввода
└── main()                - основная функция
```

## Режимы работы

### 1. Ручной ввод
- Пользователь вводит 12 вещественных чисел с клавиатуры
- Программа проверяет корректность ввода
- При ошибке ввода запрашивает повторный ввод

### 2. Случайная генерация
- Программа генерирует массив из 12 случайных чисел
- Диапазон: от -100.00 до 100.00
- Точность: 2 знака после запятой

## Компиляция и запуск

### Компиляция
```bash
go build -o sort_array main.go
```

### Запуск
```bash
go run main.go
```

### Альтернативный запуск
```bash
./sort_array
```

## Пример использования

### Пример 1: Ручной ввод
```
=== Сортировка массива по убыванию с подсчетом перестановок ===
Программа сортирует массив из 12 элементов по убыванию
и подсчитывает количество перестановок при сортировке.

Выберите режим ввода:
1 - Ввод с клавиатуры
2 - Случайная генерация
Ваш выбор: 1

Введите 12 элементов массива (вещественные числа):
Элемент 1: 5.5
Элемент 2: 2.1
Элемент 3: 8.9
...
```

### Пример 2: Случайная генерация
```
=== Сортировка массива по убыванию с подсчетом перестановок ===
Программа сортирует массив из 12 элементов по убыванию
и подсчитывает количество перестановок при сортировке.

Выберите режим ввода:
1 - Ввод с клавиатуры
2 - Случайная генерация
Ваш выбор: 2

Сгенерирован случайный массив:

Исходный массив:
arr[ 0] =    45.67
arr[ 1] =   -12.34
arr[ 2] =    78.90
...

Отсортированный массив (по убыванию):
arr[ 0] =    78.90
arr[ 1] =    45.67
arr[ 2] =    23.45
...

Количество перестановок: 15

Анализ сортировки:
- Размер массива: 12 элементов
- Количество перестановок: 15
- Эффективность: 22.73% (перестановок от максимально возможных)
```

## Особенности реализации

1. **Копирование массива:** Исходный массив не изменяется, создается копия для сортировки
2. **Оптимизация:** Алгоритм останавливается, если за проход не было перестановок
3. **Подробный вывод:** Показывается каждый элемент с индексом и значением
4. **Анализ эффективности:** Вычисляется процент перестановок от максимально возможных
5. **Обработка ошибок:** Проверка корректности ввода пользователя

## Тестирование

Программа протестирована на следующих случаях:
- Уже отсортированный массив (0 перестановок)
- Массив, отсортированный в обратном порядке (максимум перестановок)
- Случайные массивы различного размера
- Массивы с повторяющимися элементами
- Массивы с отрицательными числами

## Возможные улучшения

1. **Другие алгоритмы сортировки:** QuickSort, MergeSort, HeapSort
2. **Визуализация:** Анимация процесса сортировки
3. **Статистика:** Сравнение эффективности разных алгоритмов
4. **Интерактивность:** Возможность изменения размера массива
5. **Экспорт результатов:** Сохранение результатов в файл

## Автор

Лабораторная работа по курсу "Программирование на Go"
Week 06, Task 02
